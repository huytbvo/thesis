\section{Introduction}
\label{sec:intro}
Chisel is designed to be a {\it hardware construction language} so any
design in Chisel will always have a well defined mapping to low level
hardware blocks. Chisel's core programming features allow users to
accurately describe hardware circuits and can easily extended for
higher level hardware designs. This paper categorizes Chisel hardware
construction into three levels and discusses the merits and drawbacks
of each level.

We first introduce the core features of the Chisel hardware
construction language in Chapter~\ref{sec:chisel}. All hardware design
in Chisel boils down to writing a Scala program that builds up a directed
graph of {\tt Nodes} which are Scala classes that map to basic circuit
elements. Chisel provides basic operators for consructing and
connecting nodes into subgraphs. The subgraphs can be organized into
{\tt Components} which can be connected to other {\tt Components} to
form larger and more complex graphs. Chisel code can be mapped to many
different backends. We currently support a C++ backend for high speed
simulation and a Verilog backend to leverage existing ASIC tools.

Chapter~\ref{sec:basic} presents the lowest level of hardware
construction in Chisel. We consider this the lowest level since
Chisel code is written at the granularity of Chisel's most basic
element, {\tt Nodes}. At this hardware construction level, Chisel user
code looks identical to the targetted backend code. This can be
advantageous if the backend has syntax that the its tools can use to
synthesize efficient hardware. The downside to this is that syntax in
one backend might not have a parallel in another backend.

Moving up the abstraction ladder, Chapter~\ref{sec:advanced} presents
the next level of Chisel hardware construction in which the user
writes code using Scala functions that generate hardware. Although the
Chisel code might look similar to Chisel from Chapter~\ref{sec:basic},
the resulting Chisel graph is much denser since this hardware
construction level only uses the basic features of Chisel. Higher
level hardware facilities are abstracted away into Scala functions that
implement the same functionality using only basic Chisel {\tt
  Nodes}. Although we no longer leverage backend tool support for
special syntax, this approach has the advantage of decoupling Chisel
code from the backends.

The last level of hardware construction, Chapter~\ref{sec:elab},
analyzes and transforms Chisel graphs to produce different Chisel
graphs. This hardware construction level is similar to the hardware
construction level of Chapter~\ref{sec:advanced} in that users stil
write Scala programs to build hardware. The difference is that these
functions are invoked during elaboration time to modify a graph
instead of during runtime to build the graph. This hardware
construction level is useful for circuit designs that are difficult or
undesirable to build during runtime.

\subsection{Acknowledgements}
